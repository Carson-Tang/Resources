#pragma once
#include <bits/stdc++.h>
#include "../datastructures/FischerHeunStructure.h"
using namespace std;

// Suffix Array using Sadakane's algorithm to sort suffixes of a string in
//   lexicographical order
// Indices are 0-indexed and ranges are inclusive with the exception of
//   functions that accept two iterators as a parameter, such as
//   the constructor, which are exclusive
// rnk[i] is the rank of the suffix starting from index i
// ind[i] is the index in original string of the
//   ith lexicographically smallest suffix
// LCP[i] is the longest common prefix of the ith and (i + 1)th
//   lexicographically smallest suffix
// In practice, has a very small constant
// Time Complexity: O(S (log S)^2)
// Memory Complexity: O(S)
// Tested:
//   https://judge.yosupo.jp/problem/suffixarray
//   https://judge.yosupo.jp/problem/number_of_substrings
//   https://www.spoj.com/problems/DISUBSTR/
//   https://dmoj.ca/problem/coci06c5p6
//   https://dmoj.ca/problem/ccc20j4
//   https://dmoj.ca/problem/ccc20s3
//   https://dmoj.ca/problem/wac4p4
template <class T> struct SuffixArray {
  int N; vector<T> S; vector<int> ind, rnk, LCP;
  template <class F> SuffixArray(int N, F f)
      : N(N), ind(N + 1), rnk(N + 1), LCP(N + 1) {
    S.reserve(N); for (int i = 0; i < N; i++) S.push_back(f());
    vector<int> &tmp = LCP; iota(ind.begin(), ind.end(), 0);
    sort(ind.begin(), ind.begin() + N, [&] (int a, int b) {
      return S[a] < S[b];
    });
    rnk[ind[N]] = -1; for (int i = 0; i < N; i++) {
      rnk[ind[i]] = i > 0 && S[ind[i]] == S[ind[i - 1]] ? rnk[ind[i - 1]] : i;
    }
    for (int h = 1; h < N; h += h) for (int l = 0, r = 1; r <= N; r++) {
      if (rnk[ind[r - 1]] != rnk[ind[r]] && l + 1 < r) {
        sort(ind.begin() + l, ind.begin() + r, [&] (int a, int b) {
          return rnk[h + a] < rnk[h + b];
        });
        tmp[l] = l; for (int j = l + 1; j < r; j++)
          tmp[j] = rnk[h + ind[j - 1]] < rnk[h + ind[j]] ? j : tmp[j - 1];
        for (l++; l < r; l++) rnk[ind[l]] = tmp[l];
      } else if (rnk[ind[r - 1]] != rnk[ind[r]]) l++;
    }
    ind.pop_back(); rnk.pop_back(); tmp.pop_back();
    for (int i = 0, k = 0; i < N; i++) {
      if (rnk[i] == N - 1) { LCP[rnk[i]] = k = 0; continue; }
      int j = ind[rnk[i] + 1];
      while (i + k < N && j + k < N && S[i + k] == S[j + k]) k++;
      if ((LCP[rnk[i]] = k) > 0) k--;
    }
  }
  template <class It> SuffixArray(It st, It en)
      : SuffixArray(en - st, [&] { return *st++; }) {}
};

// Computes the longest common prefix of two suffixes of a string
//   be using the Fischer Heun Structure over the LCP array generated by the
//   Suffix Array
// Indices are 0-indexed and ranges are inclusive with the exception of
//   functions that accept two iterators as a parameter, such as
//   the constructor, which are exclusive
// lcpRnk(i, j) computes the longest common prefix of the ith and jth
//   lexicographically least suffixes
// lcp(i, j) computes the longest common prefix of the suffixes starting
//   from index i and j
// In practice, constructor has a very small constant, lcp has a
//   moderate constant, still faster than using segment trees
// Time Complexity:
//   constructor: O(S (log S)^2)
//   lcpRnk, lcp: O(1)
// Memory Complexity: O(S)
// Tested:
//   https://dmoj.ca/problem/ccc20j4
//   https://dmoj.ca/problem/ccc20s3
//   https://dmoj.ca/problem/wac4p4
template <class T> struct LongestCommonPrefix {
  SuffixArray<T> SA; FischerHeunStructure<int, greater<int>> FHS;
  template <class F> LongestCommonPrefix(int N, F f)
    : SA(N, f), FHS(SA.LCP.begin(), SA.LCP.end()) {}
  template <class It> LongestCommonPrefix(It st, It en)
      : LongestCommonPrefix(en - st, [&] { return *st++; }) {}
  int lcpRnk(int i, int j) {
    if (i > j) swap(i, j);
    return i == j ? int(SA.S.size()) - SA.ind[j] : FHS.query(i, j - 1);
  }
  int lcp(int i, int j) { return lcpRnk(SA.rnk[i], SA.rnk[j]); }
};
