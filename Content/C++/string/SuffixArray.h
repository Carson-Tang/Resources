#pragma once
#include <bits/stdc++.h>
#include "../datastructures/FischerHeunStructure.h"
using namespace std;

// Suffix Array using Sadakane's algorithm to sort suffixes of a string in
//   lexicographical order
// Indices are 0-indexed and ranges are inclusive with the exception of
//   functions that accept two iterators as a parameter, such as
//   the constructor, which are exclusive
// Template Arguments:
//   T: the type of the character/element in the string/array
// Constructor Arguments:
//   N: the length of the string/array
//   f: a generating function that returns the ith element on the ith call
//   st: an iterator pointing to the first element in the string/array
//   en: an iterator pointing to after the last element in the string/array
// Fields:
//   N: the length of the string/array
//   S: a vector of type T representing the string/array
//   rnk: a vector of the ranks of the suffices (rnk[i] is the rank of the
//     suffix starting from index i)
//   ind: a vector of the indices in the original string of the suffices
//     sorted in lexicographical order (ind[i] is the index in original string
//     of the ith lexicographically smallest suffix)
//   LCP: a vector of the longest common prefixes between the suffices when
//     sorted in lexicographical order (LCP[i] is the longest common prefix of
//     the ith and (i + 1)th lexicographically smallest suffix, with LCP[N - 1]
//     being 0)
// In practice, has a very small constant
// Time Complexity:
//   constructor: O(S (log S)^2)
// Memory Complexity: O(S)
// Tested:
//   Fuzz and Stress Tested
//   https://judge.yosupo.jp/problem/suffixarray
//   https://judge.yosupo.jp/problem/number_of_substrings
//   https://www.spoj.com/problems/DISUBSTR/
//   https://dmoj.ca/problem/coci06c5p6
//   https://dmoj.ca/problem/ccc20j4
//   https://dmoj.ca/problem/ccc20s3
template <class T> struct SuffixArray {
  int N; vector<T> S; vector<int> ind, rnk, LCP;
  template <class F> SuffixArray(int N, F f)
      : N(N), ind(N + 1), rnk(N + 1), LCP(N + 1) {
    S.reserve(N); for (int i = 0; i < N; i++) S.push_back(f());
    vector<int> &tmp = LCP; iota(ind.begin(), ind.end(), 0);
    sort(ind.begin(), ind.begin() + N, [&] (int a, int b) {
      return S[a] < S[b];
    });
    rnk[ind[N]] = -1; for (int i = 0; i < N; i++) {
      rnk[ind[i]] = i > 0 && S[ind[i]] == S[ind[i - 1]] ? rnk[ind[i - 1]] : i;
    }
    for (int h = 1; h < N; h += h) for (int l = 0, r = 1; r <= N; r++) {
      if (rnk[ind[r - 1]] != rnk[ind[r]] && l + 1 < r) {
        sort(ind.begin() + l, ind.begin() + r, [&] (int a, int b) {
          return rnk[h + a] < rnk[h + b];
        });
        tmp[l] = l; for (int j = l + 1; j < r; j++)
          tmp[j] = rnk[h + ind[j - 1]] < rnk[h + ind[j]] ? j : tmp[j - 1];
        for (l++; l < r; l++) rnk[ind[l]] = tmp[l];
      } else if (rnk[ind[r - 1]] != rnk[ind[r]]) l++;
    }
    ind.pop_back(); rnk.pop_back(); tmp.pop_back();
    for (int i = 0, k = 0; i < N; i++) {
      if (rnk[i] == N - 1) { LCP[rnk[i]] = k = 0; continue; }
      int j = ind[rnk[i] + 1];
      while (i + k < N && j + k < N && S[i + k] == S[j + k]) k++;
      if ((LCP[rnk[i]] = k) > 0) k--;
    }
  }
  template <class It> SuffixArray(It st, It en)
      : SuffixArray(en - st, [&] { return *st++; }) {}
};

// Computes the longest common prefix of two suffixes of a string
//   be using the Fischer Heun Structure over the LCP array generated by the
//   Suffix Array
// Indices are 0-indexed and ranges are inclusive with the exception of
//   functions that accept two iterators as a parameter, such as
//   the constructor, which are exclusive
// Template Arguments:
//   T: the type of the character/element in the string/array
// Constructor Arguments:
//   N: the number of elements in the string/array
//   f: a generating function that returns the ith element on the ith call
//   st: an iterator pointing to the first element in the string/array
//   en: an iterator pointing to after the last element in the string/array
// Fields:
//   SA: the associated suffix array constructed from the string/array
// Functions:
//   lcpRnk(i, j): computes the longest common prefix of the ith and jth
//     lexicographically least suffixes
//   lcp(i, j): computes the longest common prefix of the suffixes starting
//     from index i and j
// In practice, the constructor has a very small constant, lcp has a
//   moderate constant, still faster than using segment trees
// Time Complexity:
//   constructor: O(S (log S)^2)
//   lcpRnk, lcp: O(1)
// Memory Complexity: O(S)
// Tested:
//   Fuzz and Stress Tested
//   https://dmoj.ca/problem/ccc20j4
//   https://dmoj.ca/problem/ccc20s3
template <class T> struct LongestCommonPrefix {
  SuffixArray<T> SA; FischerHeunStructure<int, greater<int>> FHS;
  template <class F> LongestCommonPrefix(int N, F f)
      : SA(N, f), FHS(SA.LCP.begin(), SA.LCP.end()) {}
  template <class It> LongestCommonPrefix(It st, It en)
      : LongestCommonPrefix(en - st, [&] { return *st++; }) {}
  int lcpRnk(int i, int j) {
    if (i > j) swap(i, j);
    return i == j ? int(SA.S.size()) - SA.ind[j] : FHS.query(i, j - 1);
  }
  int lcp(int i, int j) { return lcpRnk(SA.rnk[i], SA.rnk[j]); }
};

// Finds the longest common substring of two strings
// Indices are 0-indexed and ranges are inclusive with the exception of
//   functions that accept two iterators as a parameter, such as
//   the constructor, which are exclusive
// Template Arguments:
//   T: the type of the character/element in the string/array
// Constructor Arguments:
//   N: the length of the first string/array
//   f: a generating function that returns the ith element of the first
//     string/array on the ith call
//   M: the length of the second string/array
//   g: a generating function that returns the ith element of the second
//     string/array on the ith call
//   stA: an iterator pointing to the first element in the
//     first string/array
//   enA: an iterator pointing to after the last element in
//     first string/array
//   stB: an iterator pointing to the first element in the
//     second string/array
//   enB: an iterator pointing to after the last element in
//     second string/array
// Fields:
//   SA: the associated suffix array constructed from the string/array A,
//     concatenated with the string/array B
//   lcs: the string/array of longest common substring of A and B
// In practice, the constructor has a very small constant
// Time Complexity:
//   constructor: O((N + M) (log (N + M))^2)
// Memory Complexity: O(N + M)
// Tested:
//   https://www.spoj.com/problems/LCS/
template <class T> struct LongestCommonSubstringSuffixArray {
  SuffixArray<T> SA; vector<T> lcs;
  template <class F, class G> SuffixArray<T> init(int N, F f, int M, G g) {
    int i = 0;
    return SuffixArray<T>(N + M, [&] { return i++ < N ? f() : g(); });
  }
  template <class F, class G>
  LongestCommonSubstringSuffixArray(int N, F f, int M, G g)
      : SA(init(N, f, M, g)) {
    pair<int, int> mx(-1, -1); for (int i = 0; i < N + M - 1; i++)
      if ((SA.ind[i] < N) != (SA.ind[i + 1] < N)) {
        int bnd = N - (SA.ind[i] < N ? SA.ind[i] : SA.ind[i + 1]);
        mx = max(mx, make_pair(min(SA.LCP[i], bnd), SA.ind[i]));
      }
    if (mx.first != -1) {
      lcs.reserve(mx.first);
      for (int i = 0; i < mx.first; i++) lcs.push_back(SA.S[mx.second + i]);
    }
  }
  template <class ItA, class ItB>
  LongestCommonSubstringSuffixArray(ItA stA, ItA enA, ItB stB, ItB enB)
      : LongestCommonSubstringSuffixArray(enA - stA, [&] { return *stA++; },
                                          enB - stB, [&] { return *stB++; }) {}
};
